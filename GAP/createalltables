### This is the code for creating all multigenic Laver tables. We of course do not want to keep the entire table in memory, so we use a superreduced multigenic Laver table.
### In /multigeniccreate, we produce all tables generated by 2 elements, but here we produce all tables generated by an arbitrary collection of elements.
### The code is currently a work in progress.


# makefunction returns a binary operation from an array. The binary operation is supposed to represent a Laver-like algebra.

makefunction:=function(compressedtable)
local n,tree;
n:=Length(compressedtable);
tree:=function(x,y)
if Length(compressedtable[x])=n then return compressedtable[x][y];
else
return compressedtable[x][compressedtable[Length(compressedtable[x])+1][y]];
fi;
end;
return tree;
end;

# critfind returns the list of all critical points in a Laver-like algebra. In particular, if $(X,*)$ is a Laver-like algebra, then
# critfind will return $\{c\in X\mid c*c\in\text{Li}(X)\}$.

critfind:=function(table)
local critlist,i,n,tree;
n:=Length(table);
critlist:=[];
tree:=makefunction(table);
for i in [2..n] do
if tree(i,i)=1 then Add(critlist,i); fi;
od;
Add(critlist,1);
return critlist;
end;

totalgeneration:=function(generators,table)

n:=Length(table);
mv:=makefunction(table);
critlist:=critfind(table);

superlist:=[];
for im in [1..n] do
for j in [1..Length(critlist)] do
if mv(im,critlist[j])=1 then superlist[im]:=j; break; fi;
od;
od;

superlength:=[];
supercrit:=[];

for im in [2..n] do
aa:=critlist[1+superlist[im]];
if aa>1 then superlength[im]:=aa-1; supercrit[im]:=aa;
else superlength[im]:=n; supercrit[im]:=n+1;
fi;
od;



end;

