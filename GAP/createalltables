### This is the code for creating all multigenic Laver tables. We of course do not want to keep the entire table in memory, so we use a superreduced multigenic Laver table.
### In /multigeniccreate, we produce all tables generated by 2 elements, but here we produce all tables generated by an arbitrary collection of elements.
### The code is currently a work in progress.


makefunction:=function(compressedtable)
local n,tree;
n:=Length(compressedtable);
tree:=function(x,y)
if Length(compressedtable[x])=n then return compressedtable[x][y];
else
return compressedtable[x][compressedtable[Length(compressedtable[x])+1][y]];
fi;
end;
return tree;
end;

critfind:=function(table)
local critlist,i,n,tree;
n:=Length(table);
critlist:=[];
tree:=makefunction(table);
for i in [2..n] do
if tree(i,i)=1 then Add(critlist,i); fi;
od;
Add(critlist,1);
return critlist;
end;

multigeneration:=function(generators,table)
local n,mv,critlist,gg,superlist,im,j,superlength,supercrit,mastertable,ii,aa,cart,superfunction,sumlist,testlist,tablespace,imagespace,quart,js,mlist,testlistlength,
testlistcrit,tablearray,cardarray,imagearray,pointarray,ik,tuple,jj,testfunction,test,li,kk,iz,ham,qq,aar,kz,is,sanitycheck;

n:=Length(table);
mv:=makefunction(table);
critlist:=critfind(table);
gg:=Length(generators);

superlist:=[];
for im in [1..n] do
for j in [1..Length(critlist)] do
if mv(im,critlist[j])=1 then superlist[im]:=j; break; fi;
od;
od;

superlength:=[];
supercrit:=[];

for im in [2..n] do
aa:=critlist[1+superlist[im]];
if aa>1 then superlength[im]:=aa-1; supercrit[im]:=aa;
else superlength[im]:=n; supercrit[im]:=n+1;
fi;
od;

superfunction:=function(x,y)
local ik,qq,ham;

if x=1000000000000 or y=1000000000000 then return 1000000000000; fi;
if x=1 then return y; fi;

if y>n then
for ik in [1..gg] do
if y<=sumlist[ik+1] then return superfunction(x,imagearray[ik][y-sumlist[ik]+1]); fi;
od;
if y=sumlist[Length(sumlist)]+1 then return superfunction(x,ii); fi;
Print("EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE__off.by.one.error");
fi;

if x<=n then return mv(x,y); fi;
if x=n+1 then return y; fi;
for ik in [1..gg] do
if x<=sumlist[ik+1] then
qq:=Length(tablearray[ik][x-sumlist[ik]+1])+1;
ham:=tablearray[ik][x-sumlist[ik]+1][superfunction(qq,y)];
if ham<=n+1 then return ham; else
return ham+sumlist[ik]-n-1;
fi;
fi;

od;
if x=sumlist[Length(sumlist)]+1 then
if IsBound(testlist[superfunction(testlistcrit,y)]) then return testlist[superfunction(testlistcrit,y)];
else return 1000000000000; fi;
fi;
Print("WARNING:ERROR. PLEASE FIX CODE.");
end;

sanitycheck:=function()
local a,b,c,nnq;
nnq:=sumlist[Length(sumlist)];
for a in [1..nnq] do
for b in [1..nnq] do
for c in [1..nnq] do
if not superfunction(a,superfunction(b,c))=superfunction(superfunction(a,b),superfunction(a,c)) then
while true do Display("Warning: self-distributive failure. Error in code."); od;
fi;
od;
od;
od;
end;

testfunction:=function()
local aar,li,kk;

for li in [1..gg] do
if mlist[li]>1 then
if IsBound(testlist[superfunction(testlistcrit,generators[li])]) and not testlist[superfunction(testlistcrit,generators[li])]=sumlist[li+1] then 
return false; fi;
testlist[superfunction(testlistcrit,generators[li])]:=sumlist[li+1];

elif mlist[li]=1 then

if aa[li]=1 then
if pointarray[li]=0 then
if IsBound(testlist[superfunction(testlistcrit,generators[li])]) and not testlist[superfunction(testlistcrit,generators[li])]=n+1 then return false; fi;
testlist[superfunction(testlistcrit,generators[li])]:=n+1;

elif pointarray[li]=1 then

if IsBound(testlist[superfunction(testlistcrit,generators[li])]) and not testlist[superfunction(testlistcrit,generators[li])]=1 then return false; fi;
testlist[superfunction(testlistcrit,generators[li])]:=1;

fi;
elif aa[li]>1 then

if IsBound(testlist[superfunction(testlistcrit,generators[li])]) and not testlist[superfunction(testlistcrit,generators[li])]=mv(ii,generators[li]) then
 return false; fi;
testlist[superfunction(testlistcrit,generators[li])]:=mv(ii,generators[li]);
fi;
fi;

od;

for kk in Reversed([2..testlistlength]) do
for li in [1..gg] do

aar:=superfunction(superfunction(sumlist[Length(sumlist)]+1,kk),superfunction(sumlist[Length(sumlist)]+1,generators[li]));
if aar=false then return false; fi;

if IsBound(testlist[superfunction(kk,generators[li])]) and not testlist[superfunction(kk,generators[li])]=aar then return false; fi;
testlist[superfunction(kk,generators[li])]:=aar;
od;
od;

if not testlist[1]=1 then return false; fi;

if superfunction(sumlist[Length(sumlist)]+1,ii)=1 then return false; fi;

return true;
end;


mastertable:=[];

mastertable[1]:=[];
mastertable[1][1]:=[];
mastertable[1][1][1]:=[1];
mastertable[1][1][2]:=[[1..n]];
mastertable[1][1][3]:=0;
mastertable[1][2]:=[];
mastertable[1][2][1]:=[1];
mastertable[1][2][2]:=[[1..n]];
mastertable[1][2][3]:=1;




for ii in [2..n] do

mastertable[ii]:=[];
if mv(ii,ii)=1 then
mastertable[ii][1]:=[[1],[[1..n]],1];
fi;

aa:=[];
#doubleaa:=[];
#beginaa:=[];
for jj in [1..gg] do
aa[jj]:=mv(ii,generators[jj]);
#doubleaa[jj]:=mv(aa[jj],aa[jj]);
#if doubleaa[jj]>1 then
#beginaa[jj]:=2;
#else
#beginaa[jj]:=1;
#fi;
od;


cart:=Cartesian(List(aa,v->[1..Length(mastertable[v])]));
#cart:=Cartesian(List([1..gg],v->[beginaa[v]..Length(mastertable[aa[v]])]));

for tuple in cart do

cardarray:=List([1..gg],v->mastertable[aa[v]][tuple[v]]);
imagearray:=List(cardarray,v->v[1]);
tablearray:=List(cardarray,v->v[2]);
pointarray:=List(cardarray,v->v[3]);

mlist:=List([1..gg],v->Length(imagearray[v]));

sumlist:=[n+1];

for iz in [1..gg] do
sumlist[iz+1]:=sumlist[iz]+mlist[iz]-1;
od;

testlist:=[];
testlistlength:=superlength[ii];
testlistcrit:=supercrit[ii];

test:=testfunction();

if test then

imagespace:=ShallowCopy(imagearray[1]);
for kz in [2..gg] do
for is in [2..Length(imagearray[kz])] do
Add(imagespace,imagearray[kz][is]);
od;
od;


tablespace:=ShallowCopy(tablearray[1]);

for kz in [2..gg] do
for is in [2..Length(tablearray[kz])] do
quart:=ShallowCopy(tablearray[kz][is]);
for js in [1..Length(quart)] do
if quart[js]>n+1 then
quart[js]:=quart[js]+sumlist[kz]-n-1;
fi;
od;
Add(tablespace,quart);

od;
od;


if superfunction(sumlist[Length(sumlist)]+1,critlist[superlist[ii]])=1 then
while Length(testlist)>=critlist[superlist[ii]] do Remove(testlist); od;
fi;

Add(imagespace,ii);
Add(tablespace,testlist);
Add(mastertable[ii],[imagespace,tablespace,0]);

fi;

od;
od;

return List(generators,v->mastertable[v]); 
end;

multiextendtable:=function(type,generators,table,extension)
local mix,newtable,mv,newgenerators,i,a,b,c,imagespace,tablespace,quart,newfunction
,n,kz,sumlist,js,tablearray,gg,is,imagearray,finalcritlist,mlist,aa,ii,jj,iz,cardarray,pointarray;

n:=Length(table);
mix:=[];
newtable:=StructuralCopy(table);
finalcritlist:=critfind(table);
gg:=Length(generators);

Add(finalcritlist,n+1);

mv:=makefunction(table);
newgenerators:=[];

cardarray:=List([1..gg],v->extension[v][type[v]]);
#cardarray:=List([1..gg],v->mastertable[aa[v]][tuple[v]]);
imagearray:=List(cardarray,v->v[1]);
tablearray:=List(cardarray,v->v[2]);
pointarray:=List(cardarray,v->v[3]);
mlist:=List([1..gg],v->Length(imagearray[v]));
sumlist:=[n+1]; 
for iz in [1..gg] do
sumlist[iz+1]:=sumlist[iz]+mlist[iz]-1;
od;

imagespace:=ShallowCopy(imagearray[1]);
for kz in [2..gg] do
for is in [2..Length(imagearray[kz])] do
Add(imagespace,imagearray[kz][is]);
od;
od;

# Here structural copy works, but there may be something better I can use.
tablespace:=StructuralCopy(tablearray[1]);

for kz in [2..gg] do for is in [2..Length(tablearray[kz])] do 
quart:=ShallowCopy(tablearray[kz][is]);
for js in [1..Length(quart)] do if quart[js]>n+1 then quart[js]:=quart[js]+sumlist[kz]-n-1; fi; od; Add(tablespace,quart);
od; od;

Append(newtable,tablespace);

for a in finalcritlist do
if a>1 then
for b in imagespace do
Add(newtable[a],newtable[a][b]);
od;
fi;
od;
Append(newtable[1],[n+1..n+Length(imagespace)]);

for i in [1..gg] do
if mlist[i]>1 then
newgenerators[i]:=sumlist[i+1];
else
if generators[i]>1 then newgenerators[i]:=generators[i]; else
if pointarray[i]=0 then
newgenerators[i]:=n+1;
elif pointarray[i]=1 then
newgenerators[i]:=1;
fi;
fi;
fi;
od;

#tablespace:=ShallowCopy(tablearray[1]);
#for kz in [2..gg] do
#for is in [2..Length(tablearray[kz])] do
#quart:=ShallowCopy(tablearray[kz][is]);
#for js in [1..Length(quart)] do
#if quart[js]>n+1 then
#quart[js]:=quart[js]+sumlist[kz]-n-1;
#di;
#od;
#Add(tablespace,quart);
#od;
#od;

# I should add a line here that puts all the imagearrays into a single row.

newfunction:=makefunction(newtable);
#for a in [1..Length(newtable)] do
#for b in [1..Length(newtable)] do
#for c in [1..Length(newtable)] do
#if not newfunction(a,newfunction(b,c))=newfunction(newfunction(a,b),newfunction(a,c)) then while true do Display("E"); od; fi;
#od; od; od;



return [newgenerators,newtable];
end;

allmultiextensions:=function(generators,table)
local ext,cart,tuple,output,improper,i,j,cont,imagecheck,tablecheck,pointcheck,n,iz,gg,safe;
output:=[];
n:=Length(table);
gg:=Length(generators);
mv:=makefunction(table);
ext:=multigeneration(generators,table);
cart:=Cartesian(List(ext,v->[1..Length(v)]));

improper:=[];

for i in [1..Length(ext)] do

for j in [1..Length(ext[i])] do

imagecheck:=ext[i][j][1];
tablecheck:=ext[i][j][2];
pointcheck:=ext[i][j][3];

cont:=false;

for iz in [2..Length(tablecheck)] do
if n+1 in tablecheck[iz] then cont:=true; fi;
od;

if generators[i]=1 and pointcheck=0 then cont:=true; fi;

if cont then continue; fi;

# Now we need a condition here where we 

Add(improper,j); break;
od;
od;
safe:=false;
for tuple in cart do
if tuple=improper then safe:=true; continue; fi;
Add(output,multiextendtable(tuple,generators,table,ext));
od;

if not safe then
while true do Print("E"); od;
fi;

return output;
end;

nightmaretest:=function(x)
local critlist,i,k,mv;
critlist:=critfind(x);
mv:=makefunction(x);
for i in [1..Length(x)] do
for k in critlist do
if mv(mv(i,i),k)=1 and not mv(i,k)=1 then return false; fi;
od;
od;
return true;
end;

critequaltest:=function(a,b,table)
local n,mv,ttt,i,aa,bb,pna,taa,tbb,list,pan;
n:=Length(table);
mv:=makefunction(table);

ttt:=[];
for i in [1..n] do ttt[i]:=[]; od;

list:=[];

for i in [1..n] do 
aa:=mv(i,a);
bb:=mv(i,b);
if not (aa=1)=(bb=1) then return false; fi;
if not IsBound(ttt[aa][bb]) then 
ttt[aa][bb]:=true; 
if aa>1 then Add(list,[aa,bb]); fi;
fi;
od;

while Length(list)>0 do
pan:=Remove(list);
taa:=pan[1];
tbb:=pan[2];
if not Length(table[taa])=Length(table[tbb]) then return false; fi;

for i in [1..Length(table[taa])] do
aa:=table[taa][i];
bb:=table[tbb][i];
if not (aa=1)=(bb=1) then return false; fi;
if not IsBound(ttt[aa][bb]) then 
ttt[aa][bb]:=true; 
if aa>1 then Add(list,[aa,bb]); fi;
fi;
od;
od;

return true;
end;




#Beyond this point, there is nothing interesting. I am just saving it since I don't want to throw it away just yet.
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

#totalgeneration:=function(limit,zero,one,table)
#local im,n,mv,critlist,superlist,i,j,superlength,supercrit,aa,ii,superfunction,doublesuperfunction,imagezero,imageone,testlistcrit,testlistlength,mzero,mone,tablezero,tableone,
#mastertable,bb,qq,imagespace,card,cardzero,cardone,mm,tablespace,qqq,rrr,jj,kk,testfunction,test,aar,bbr,newtablespace,newimagespace,testlist,ttt,doubletestfunction,quart,is,js,ri,rj,ham,
#parkzero,parkone,aaa,b;

#n:=Length(table);

#mv:=makefunction(table);
#critlist:=critfind(table);

#superlist:=[];
#for im in [1..n] do
#for j in [1..Length(critlist)] do
#if mv(im,critlist[j])=1 then superlist[im]:=j; break; fi;
#od;
#od;

#superlength:=[];
#supercrit:=[];

#for im in [2..n] do
#aa:=critlist[1+superlist[im]];
#if aa>1 then superlength[im]:=aa-1; supercrit[im]:=aa;
#else superlength[im]:=n; supercrit[im]:=n+1;
#fi;
#od;

#mastertable:=[];

#mastertable[1]:=[];
#mastertable[1][1]:=[];
#mastertable[1][1][1]:=[1];
#mastertable[1][1][2]:=[[1..n]];


#superfunction:=function(x,y)
#if x=1000000000000 or y=1000000000000 then return 1000000000000; fi;
#i#f x=1 then return y; fi;
#if y>n then return superfunction(x,imagespace[y-n]); fi;
#if x<=n then return mv(x,y); fi;
#if x=n+1 then return y; fi;
#if x<=n+mm then
#qq:=Length(tablespace[x-n])+1;
#return tablespace[x-n][superfunction(qq,y)];
#fi;
#if x=n+mm+1 then 
#if IsBound(testlist[superfunction(testlistcrit,y)]) then return testlist[superfunction(testlistcrit,y)];
#else return 1000000000000; fi;
#fi;
#Print("WARNING:OFF.BY.ONE.ERROR");
#end;


#doublesuperfunction:=function(x,y)
#i#f x=1000000000000 or y=1000000000000 then return 1000000000000; fi;
#if x=1 then return y; fi;
#if y>n then
#i#f y<=n+mzero then return doublesuperfunction(x,imagezero[y-n]);
#elif y<=n+mzero+mone-1 then return doublesuperfunction(x,imageone[y-n-mzero+1]); 
#elif y=n+mzero+mone then return doublesuperfunction(x,ii);
#else Print("EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE__off.by.one.error");
#fi;
#fi;

#i#f x<=n then return mv(x,y); fi;
#if x=n+1 then return y; fi;
#if x<=n+mzero then
#qq:=Length(tablezero[x-n])+1;
#return tablezero[x-n][doublesuperfunction(qq,y)];
#fi;
#if x<=n+mzero+mone-1 then
#qq:=Length(tableone[x-n-mzero+1])+1;
#ham:=tableone[x-n-mzero+1][doublesuperfunction(qq,y)];
#if ham<=n+1 then return ham;
#else return ham+mzero-1;
#fi;

#fi;
#if x=n+mzero+mone then
#if IsBound(testlist[doublesuperfunction(testlistcrit,y)]) then return testlist[doublesuperfunction(testlistcrit,y)]; else
#return 1000000000000; fi;
#fi;
#end;

#doubletestfunction:=function()

#if IsBound(testlist[doublesuperfunction(testlistcrit,zero)]) then if not testlist[doublesuperfunction(testlistcrit,zero)]=n+mzero then return false; fi; fi;
#testlist[doublesuperfunction(testlistcrit,zero)]:=n+mzero;

#if mone>1 then

#if IsBound(testlist[doublesuperfunction(testlistcrit,one)]) then if not testlist[doublesuperfunction(testlistcrit,one)]=n+mzero+mone-1 then return false; fi; fi;
#testlist[doublesuperfunction(testlistcrit,one)]:=n+mzero+mone-1;

#elif mone=1 then

#if IsBound(testlist[doublesuperfunction(testlistcrit,one)]) then if not testlist[doublesuperfunction(testlistcrit,one)]=n+1 then return false; fi; fi;
#testlist[doublesuperfunction(testlistcrit,one)]:=n+1;

#else Print("EEEEEEEEEEEE"); fi;

#for kk in Reversed([2..testlistlength]) do
#aar:=doublesuperfunction(doublesuperfunction(n+mzero+mone,kk),doublesuperfunction(n+mzero+mone,zero));
#if aar=false then return false; fi;
#if IsBound(testlist[doublesuperfunction(kk,zero)]) and not testlist[doublesuperfunction(kk,zero)]=aar then return false; fi;
#testlist[doublesuperfunction(kk,zero)]:=aar;

#bbr:=doublesuperfunction(doublesuperfunction(n+mzero+mone,kk),doublesuperfunction(n+mzero+mone,one));
#if bbr=false then return false; fi;
#if IsBound(testlist[doublesuperfunction(kk,one)]) and not testlist[doublesuperfunction(kk,one)]=bbr then return false; fi;
#testlist[doublesuperfunction(kk,one)]:=bbr;

#od;

#if not testlist[1]=1 then return false; fi;

#if doublesuperfunction(n+mzero+mone,ii)=1 then return false; fi;

#return true;
#end;


#testfunction:=function()

#if ttt=0 then card:=mastertable[aa][jj]; else card:=mastertable[bb][jj-qqq]; fi;


#if ttt=0 then
#if IsBound(testlist[superfunction(testlistcrit,zero)]) then if not testlist[superfunction(testlistcrit,zero)]=n+mm then 
#return false; fi; fi;
#testlist[superfunction(testlistcrit,zero)]:=n+mm;

#if IsBound(testlist[superfunction(testlistcrit,one)]) then if not testlist[superfunction(testlistcrit,one)]=mv(ii,one) then 
#return false; fi; fi;
#testlist[superfunction(testlistcrit,one)]:=mv(ii,one);
#else

#if IsBound(testlist[superfunction(testlistcrit,zero)]) then if not testlist[superfunction(testlistcrit,zero)]=mv(ii,zero) then 
#return false; fi; fi;
#testlist[superfunction(testlistcrit,zero)]:=mv(ii,zero);

#if IsBound(testlist[superfunction(testlistcrit,one)]) then if not testlist[superfunction(testlistcrit,one)]=n+mm then 
#return false; fi; fi;
#testlist[superfunction(testlistcrit,one)]:=n+mm;
#fi;

#for kk in Reversed([2..testlistlength]) do
#aar:=superfunction(superfunction(n+mm+1,kk),superfunction(n+mm+1,zero));
#if aar=false then return false; fi;
#if IsBound(testlist[superfunction(kk,zero)]) and not testlist[superfunction(kk,zero)]=aar then 
# return false; fi;
#testlist[superfunction(kk,zero)]:=aar;

#bbr:=superfunction(superfunction(n+mm+1,kk),superfunction(n+mm+1,one));
#if bbr=false then return false; fi;
#if IsBound(testlist[superfunction(kk,one)]) and not testlist[superfunction(kk,one)]=bbr then 
#return false; fi;
#testlist[superfunction(kk,one)]:=bbr;

#od;

#if not testlist[1]=1 then 
#return false; fi;

#if superfunction(n+mm+1,ii)=1 then return false; fi;

#return true;
#end;


#for ii in [2..n] do

#aa:=mv(ii,zero);
#bb:=mv(ii,one);
#mastertable[ii]:=[];

#if mv(ii,ii)>1 and mv(aa,aa)=1 and mv(bb,bb)=1 then
#imagespace:=[1,ii];
#tablespace:=[[1..n],StructuralCopy(table[ii])];

#Add(mastertable[ii],[imagespace,tablespace]);
#fi;


#qqq:=Length(mastertable[aa]);
#rrr:=Length(mastertable[bb]);

#for jj in [1..qqq+rrr] do
#if jj<=qqq then ttt:=0; else ttt:=1; fi;

#if ttt=0 and mv(bb,bb)>1 then continue; fi;
#if ttt=1 and mv(aa,aa)>1 then continue; fi;

#if ttt=0 then card:=mastertable[aa][jj]; else card:=mastertable[bb][jj-qqq]; fi;
#imagespace:=card[1];
#tablespace:=card[2];
#mm:=Length(imagespace);

#if mm+1>limit then continue; fi;

#testlist:=[];
#testlistlength:=superlength[ii];
#testlistcrit:=supercrit[ii];

#test:=testfunction();

#if test then
#newimagespace:=ShallowCopy(imagespace);
#newtablespace:=ShallowCopy(tablespace);


#if superfunction(n+mm+1,critlist[superlist[ii]])=1 then
#while Length(testlist)>=critlist[superlist[ii]] do Remove(testlist); od;
#fi;

#Add(newimagespace,ii);
#Add(newtablespace,testlist);

#Add(mastertable[ii],[newimagespace,newtablespace]);

#fi;

#od;

#for ri in [1..Length(mastertable[aa])] do
#for rj in [1..Length(mastertable[bb])] do

#cardzero:=mastertable[aa][ri];
#cardone:=mastertable[bb][rj];

#imagezero:=cardzero[1];
#imageone:=cardone[1];

#tablezero:=cardzero[2];
#tableone:=cardone[2];

#mzero:=Length(imagezero);
#mone:=Length(imageone);

#if mzero+mone>limit then continue; fi;

#testlist:=[];
#testlistlength:=superlength[ii];
#testlistcrit:=supercrit[ii];

#test:=doubletestfunction();
#if test then
#imagespace:=ShallowCopy(imagezero);
#tablespace:=ShallowCopy(tablezero);
#for is in [2..Length(imageone)] do
#Add(imagespace,imageone[is]);
#od;
#for is in [2..Length(tableone)] do
#quart:=ShallowCopy(tableone[is]);
#for js in [1..Length(quart)] do
#if quart[js]>n+1 then
#quart[js]:=quart[js]+mzero-1;
#fi;
#od;

#Add(tablespace,quart);
#od;

#if doublesuperfunction(n+mzero+mone,critlist[superlist[ii]])=1 then
#while Length(testlist)>=critlist[superlist[ii]] do Remove(testlist); od;
#fi;

#Add(imagespace,ii);
#Add(tablespace,testlist);

#Add(mastertable[ii],[imagespace,tablespace]);
#fi;

#od;
#od;


#od;

#parkzero:=[];
#parkone:=[];

#Here we have an issue of the table not accepting generators. Sad.

#for card in mastertable[zero] do
#test:=false;
#tablespace:=card[2];
#for aaa in tablespace do
#if test then break; fi;
#for b in aaa do
#if b=n+1 then test:=true; break; fi;
#od;
#od;
#if test or Length(tablespace)=1 then Add(parkzero,card); fi;
#od;
#for card in mastertable[one] do
#test:=false;
#tablespace:=card[2];
#for aaa in tablespace do
#if test then break; fi;
#for b in aaa do
#if b=n+1 then test:=true; break; fi;
#od;
#od;
#if test or Length(tablespace)=1 then Add(parkone,card); fi;
#od;

#cow:=cow;

#return [mastertable[zero],mastertable[one]];

##########return [parkzero,parkone];
#end;


#extendtable:=function(type,number,xx,extension)
#local har,n,quack,i,j,mzero,hack,rack,zeroext,oneext;

#n:=Length(xx[3]);

#if type<2 then
#if type=0 then
#Append(xx[3],StructuralCopy(extension[1][number][2]));
#xx[1]:=Length(xx[3]);
#Append(xx[3][n+1],StructuralCopy(extension[1][number][1]));
#for i in [1..n] do
#if Length(xx[3][i])=n then Append(xx[3][i],StructuralCopy(List(extension[1][number][1],v->xx[3][i][v]))); fi;
#od;
#xx[3][1]:=[1..Length(xx[3][1])];
#else
#Append(xx[3],StructuralCopy(extension[2][number][2]));
#xx[2]:=Length(xx[3]);
#Append(xx[3][n+1],StructuralCopy(extension[2][number][1]));
#fi;
#for i in [1..n] do
#if Length(xx[3][i])=n then Append(xx[3][i],StructuralCopy(List(extension[2][number][1],v->xx[3][i][v]))); fi;
#od;
#xx[3][1]:=[1..Length(xx[3][1])];
#else

#zeroext:=StructuralCopy(extension[1][number[1]]);
#oneext:=StructuralCopy(extension[2][number[2]]);

#Append(xx[3],zeroext[2]);
#xx[1]:=Length(xx[3]);

#Append(xx[3][n+1],zeroext[1]);

#mzero:=Length(zeroext[2]);

#har:=StructuralCopy(oneext[2]);

#for i in [2..Length(har)] do
#quack:=har[i];
#for j in [1..Length(quack)] do
#if quack[j]>n+1 then 
#quack[j]:=quack[j]+mzero-1;
#fi;
#od;
#Add(xx[3],quack);
#od;


#xx[2]:=Length(xx[3]);

#if Length(oneext[2])=1 then
#xx[2]:=n+1;
#fi;


#hack:=StructuralCopy(zeroext[1]);

#rack:=StructuralCopy(oneext[1]);


#for i in [2..Length(rack)] do
#if rack[i]<=n+1 then Add(hack,rack[i]);
#else
#Add(hack,rack[i]+mzero-1);
#fi;
#od;

#for i in [1..n] do
#if Length(xx[3][i])=n then Append(xx[3][i],List(hack,v->xx[3][i][v])); fi;
#od;
#xx[3][1]:=[1..Length(xx[3][1])];
#xx[3][n+1]:=Concatenation([1..n],hack);

#fi;

#end;



#allextensions:=function(tar,x)
#local ext,list,i,xx,newext,j,full,limit,n,marchlist,card,test,aaa,b,tablespace;

#mv:=makefunction(x[3]);

#n:=Length(x[3]);

#if not IsInt(tar) then limit:=infinity; else limit:=tar; fi;
#full:=not (tar=false);

#ext:=totalgeneration(limit,x[1],x[2],x[3]);
#list:=[];

#marchlist:=[[],[]];

#for card in ext[1] do
#test:=false;
#tablespace:=card[2];
#for aaa in tablespace do
#if test then break; fi;
#for b in aaa do
#if b=n+1 then test:=true; break; fi;
#od;
#od;
#if test or Length(tablespace)=1 then Add(marchlist[1],1); 
#else Add(marchlist[1],0); fi;
#od;

#for card in ext[2] do
#test:=false;
#tablespace:=card[2];
#for aaa in tablespace do
#if test then break; fi;
#for b in aaa do
#if b=n+1 then test:=true; break; fi;
#od;
#od;
#if test or Length(tablespace)=1 then Add(marchlist[2],1); 
#else Add(marchlist[2],0); fi;
#od;



#for i in [1..Length(ext[1])] do
#if mv(x[2],x[2])>1 then break; fi;

#if Length(ext[1][i][2])>limit then continue; fi;

#if marchlist[1][i]=0 then continue; fi;

#xx:=StructuralCopy(x);
#extendtable(0,i,xx,ext);



#Add(list,xx);
#od;
#for j in [1..Length(ext[2])] do
#if mv(x[1],x[1])>1 then break; fi;

#if Length(ext[2][j][2])>limit then continue; fi;

#if marchlist[2][j]=0 then continue; fi;

#xx:=StructuralCopy(x);
#extendtable(1,j,xx,ext);
#Add(list,xx);
#od;

#if full then
#for i in [1..Length(ext[1])] do
#for j in [1..Length(ext[2])] do
#if Length(ext[1][i][2])+Length(ext[2][j][2])-1>limit then continue; fi;

#if marchlist[1][i]=0 and marchlist[2][j]=0 then continue; fi;

#xx:=StructuralCopy(x);
#extendtable(2,[i,j],xx,ext);
#Add(list,xx);
#od;
#od;
#fi;
#return list;
#end;

#expandtable:=function(table)
#local n,mv,ttt;
#n:=Length(table);
#mv:=makefunction(table);
#ttt:=List([1..n],u->List([1..n],v->mv(u,v)));
#return ttt;
#end;

#russiancombinetable:=function(n,tablezero,tableone)
#local mzero,mone,tablespace,adjrow,is,js,i,j;

#mzero:=Length(tablezero);
#mone:=Length(tableone);
#tablespace:=StructuralCopy(tablezero);

#for is in [n+2..mone] do
#Add(tablespace[n+1],tableone[n+1][is]);
#a#djrow:=[];
#for js in [1..n] do
#if tableone[is][js]<=n+1 then adjrow[js]:=tableone[is][js];
#else
#adjrow[js]:=tableone[is][js]+mzero-(n+1);
#fi;
#od;

#Add(tablespace,adjrow);
#od;

#for j in [1..Length(tablespace)] do
#tablespace[1][j]:=j;
#for i in [2..Length(tablespace)] do
#tablespace[i][j]:=tablespace[i][tablespace[n+1][j]];
#od;
#od;

#r#eturn tablespace;
#end;

#generationtest:=function(x)
#local zero,one,table,n,axe,m,i,j;
#zero:=x[1];
#one:=x[2];
#table:=x[3];
#n:=Length(table);

#axe:=[zero,one];

#m:=Length(axe);
#while true do
#for i in [1..m] do
#for j in [1..m] do
#Add(axe,table[axe[i]][axe[j]]);
#od;
#od;
#axe:=Unique(axe);
#if Length(axe)=m then break; fi;
#m:=Length(axe);
#od;
#return n=m;
#end;


# I need to modify the russianextension function some more.
# We can only go from below to above if we hit a critical point. i.e. We can only go from below to above once we hit a square root of 1.

# aa=exttable[i][zero];
# bb=exttable[i][one];
# If the new element is less than 1
#

#russianextension:=function(zero,one,table)
#local n,exttable,mastertable,aa,bb,qqq,rrr,rj,rk,cardzero,cardone,tablezero,tableone,pointzero,pointone,mzero,mone,tablespace,doweaddtable,is,pp,js,i;

#n:=Length(table);
#exttable:=StructuralCopy(table);
#e#xttable[n+1]:=[1..n];
#exttable[1][n+1]:=n+1;
#for i in [2..n+1] do
#exttable[i][n+1]:=1;
#od;

#mastertable:=[];
#mastertable[1]:=[[StructuralCopy(exttable),0],[StructuralCopy(exttable),1]];

#for i in [2..n] do
#mastertable[i]:=[];

#Add(mastertable[i],[StructuralCopy(exttable),2]);

#aa:=exttable[i][zero];
#bb:=exttable[i][one];

#for cardzero in mastertable[aa] do
#for cardone in mastertable[bb] do

#doweaddtable:=true;

#tablezero:=cardzero[1];
#tableone:=cardone[1];
#pointzero:=cardzero[2];
#pointone:=cardone[2];
#mzero:=Length(tablezero);
#mone:=Length(tableone);

#tablespace:=russiancombinetable(n,tablezero,tableone);

#Add(tablespace,[]);

#pp:=Length(tablespace);

#tablespace[1][pp]:=pp;
#for is in [2..pp-1] do tablespace[is][pp]:=tablespace[is][i]; od;

#if mzero>n+1 then 
#if IsBound(tablespace[pp][zero]) and not tablespace[pp][zero]=mzero then doweaddtable:=false; fi;
#tablespace[pp][zero]:=mzero;
#else
#i#f aa>1 or pointzero>0 then 
#if IsBound(tablespace[pp][zero]) and not tablespace[pp][zero]=aa then doweaddtable:=false; fi;
#tablespace[pp][zero]:=aa; 
#fi;
#if aa=1 and pointzero=0 then 
#if IsBound(tablespace[pp][zero]) and not tablespace[pp][zero]=n+1 then doweaddtable:=false; fi;
#tablespace[pp][zero]:=n+1; 
#fi;
#fi;
###################if IsBound( ) and not  then doweaddtable:=false; fi;

#if mone>n+1 then 
#if IsBound(tablespace[pp][one]) and not tablespace[pp][one]=pp-1 then doweaddtable:=false; fi;
#tablespace[pp][one]:=pp-1;
#else
#if bb>1 or pointone>0 then 
#if IsBound(tablespace[pp][one]) and not tablespace[pp][one]=bb then doweaddtable:=false; fi;
#tablespace[pp][one]:=bb; 
#fi;
#if bb=1 and pointone=0 then 
#if IsBound(tablespace[pp][one]) and not tablespace[pp][one]=n+1 then doweaddtable:=false; fi;
#tablespace[pp][one]:=n+1; 
#fi;
#fi;

#for is in Reversed([2..n]) do
#if IsBound(tablespace[pp][tablespace[is][zero]]) and not tablespace[pp][tablespace[is][zero]]=tablespace[tablespace[pp][is]][tablespace[pp][zero]] then doweaddtable:=false; fi;
#tablespace[pp][tablespace[is][zero]]:=tablespace[tablespace[pp][is]][tablespace[pp][zero]];

#if IsBound(tablespace[pp][tablespace[is][one]]) and not tablespace[pp][tablespace[is][one]]=tablespace[tablespace[pp][is]][tablespace[pp][one]] then doweaddtable:=false; fi;
#tablespace[pp][tablespace[is][one]]:=tablespace[tablespace[pp][is]][tablespace[pp][one]];
#od;

#for is in [n+1..pp] do
#tablespace[pp][is]:=tablespace[pp][tablespace[n+1][is]];
#od;

#if tablespace[pp][pp]=1 then continue; fi;



#if tablespace[pp][zero]<=n and tablespace[tablespace[pp][zero]][tablespace[pp][zero]]>1 then doweaddtable:=false; fi;
#if tablespace[pp][one]<=n and tablespace[tablespace[pp][one]][tablespace[pp][one]]>1 then doweaddtable:=false; fi;

#if doweaddtable 
##################and fulldistributivitytest(tablespace) 
#then Add(mastertable[i],[tablespace,3]); fi;
#od;
#od;

#od;

#parkzero:=[];
#parkone:=[];

#for aa in parkzero do
#if midtabletest(0,newzero,newone,newtable) then Add(parkzero,aa); fi;
#od;
#for bb in parkone do
#if midtabletest(0,newzero,newone,newtable) then Add(parkone,bb); fi;
#od;

#############33return [parkzero,parkone];

#return [mastertable[zero],mastertable[one]];
#end;





#midtabletest:=function(bit,zero,one,table)
#local critlist,a,b,i,j,maxcrit;

#if not fullgenerationtest([zero,one],table) then return false; fi;

#critlist:=critfind(table);
#maxcrit:=Maximum(critlist);
#Remove(critlist);
#Add(critlist,Length(table)+1);
#for i in [2..Length(critlist)] do
#a:=critlist[i-1];
#b:=critlist[i];
#for j in [a+1..b-1] do
#if table[j][zero]<a and table[table[j][zero]][table[j][zero]]>1 then return false; fi;
#if table[j][one]<a and table[table[j][one]][table[j][one]]>1 then return false; fi;
#od;
#od;

#if not bit=1 then if table[zero][zero]>1 and zero<maxcrit then return false; fi; fi;
#if not bit=0 then if table[one][one]>1 and one<maxcrit then return false; fi; fi;

#return true;
#end;




# I can probably extend the midtabletest to a left midtable test and a right midtable test.

#fastmidtabletest:=function(zero,one,table)
#local critlist,a,b,i,j,maxcrit;
#critlist:=critfind(table);
#maxcrit:=Maximum(critlist);
#n:=Length(table);

#return true;
#end;


#For russianallextensions or the above function, we need to be able to eliminate the cases where we do not generate the new critical point with the same two elements.
#However, we only need to be able to generate the new critical point in one way.

#russiangentest:=function(n,zero,one,table)
#local a,b,c,list;
#if Length(table)<=n+1 then return true; fi;
#list:=[Length(table)];
#while Length(list)>0 do
#a:=Remove(list);
#if a=n+1 then return true; fi;
#b:=table[a][zero];
#c:=table[a][one];
#if b>n then Add(list,b); fi;
#if c>n then Add(list,c); fi;
#od;
#return false;
#end;

#multirussiangentest:=function(n,generators,table)
#local a,b,c,list;

#if Length(table)<=n+1 then return true; fi;
#list:=[Length(table)];
#while Length(list)>0 do
#a:=Remove(list);
#if a=n+1 then return true; fi;
#for b in generators do
#c:=table[a][b];
#if c>n then Add(list,c); fi;
#od;
#od;
#return false;
#end;


#russianallextensions:=function(x)
#local gentestkey,zero,one,table,n,cardzero,cardone,tablezero,tableone,pointzero,pointone,output,ext,mzero,mone,tablespace,newzero,newone,amm,preext,i;

#zero:=x[1];
#one:=x[2];
#table:=x[3];
#n:=Length(table);
#output:=[];

#ext:=russianextension(zero,one,table);

#gentestkey:=[[],[]];

#for i in [1,2] do
#for j in [1..Length(ext[i])] do
#gentestkey[i][j]:=russiangentest(n,zero,one,ext[i][j][1]);
#od;
#od;

#for i in [1..Length(ext[1])] do
#for j in [1..Length(ext[2])] do
#if not gentestkey[1][i] and not gentestkey[2][j] then continue; fi;

#cardzero:=ext[1][i];
#cardone:=ext[2][j];
#tablezero:=cardzero[1];
#tableone:=cardone[1];
#pointzero:=cardzero[2];
#p#ointone:=cardone[2];
#mzero:=Length(tablezero);
#mone:=Length(tableone);
#tablespace:=russiancombinetable(n,tablezero,tableone);

############### I NEED TO MODIFY THE FOLLOWING STATEMENTS!

#if mzero>n+1 then newzero:=mzero;
#elif zero>1 then newzero:=zero;
#elif zero=1 and pointzero=0 then newzero:=n+1;
#elif zero=1 and pointzero=1 then newzero:=1;
#fi;

#if mone>n+1 then newone:=Length(tablespace);
#elif one>1 then newone:=one;
#elif one=1 and pointone=0 then newone:=n+1;
#elif one=1 and pointone=1 then newone:=1;
#fi;

#if newone>n or newzero>n then
#Add(output,[newzero,newone,tablespace]);
#fi;
#od;
#od;

#return output;
#end;


##################### I need to write the code for determining whether 


#strongrussianallextensions:=function(xx) local pan,y,can; can:=russianallextensions(xx); pan:=[]; for y in can do if midtabletest(true,y[1],y[2],y[3]) then Add(pan,y); fi; od; return pan; end;

#multicombine:=function(n,tablelist)
#local i,tablespace,gg;

#gg:=Length(tablelist);
#tablespace:=StructuralCopy(tablelist[1]);
#for i in [2..gg] do
#tablespace:=russiancombinetable(n,tablespace,tablelist[i]);
#od;
#return tablespace;
#end;

#multirussianextension:=function(generators,table)
#local n,exttable,i,mastertable,aa,cart,tuple,cardarray,tablearray,pointarray,tablespace,doweaddtable,pp,ks,gg,is,sumlist,iz,mlonglist,mlist,j,jj,ih;

#n:=Length(table);
#exttable:=StructuralCopy(table);
#exttable[n+1]:=[1..n];
#exttable[1][n+1]:=n+1;
#for i in [2..n+1] do
#exttable[i][n+1]:=1;
#od;
#gg:=Length(generators);

#mastertable:=[];
#mastertable[1]:=[[StructuralCopy(exttable),0],[StructuralCopy(exttable),1]];

#for i in [2..n] do
#mastertable[i]:=[];

#Add(mastertable[i],[StructuralCopy(exttable),2]);
#aa:=[];
#for jj in [1..gg] do
#aa[jj]:=exttable[i][generators[jj]];
#od;

#cart:=Cartesian(List(aa,v->[1..Length(mastertable[v])]));

#for tuple in cart do

#cardarray:=List([1..gg],v->mastertable[aa[v]][tuple[v]]);

#tablearray:=List(cardarray,v->v[1]);
#pointarray:=List(cardarray,v->v[2]);

#tablespace:=multicombine(n,tablearray);

#doweaddtable:=true;

#mlonglist:=List(tablearray,Length);

#mlist:=mlonglist-n;

#sumlist:=[n+1];

#for iz in [1..gg] do
#sumlist[iz+1]:=sumlist[iz]+mlist[iz]-1;
#od;

#Add(tablespace,[]);

#pp:=Length(tablespace);

#tablespace[1][pp]:=pp;
#for is in [2..pp-1] do tablespace[is][pp]:=tablespace[is][i]; od;

#for ih in [1..gg] do
#if mlonglist[ih]>n+1 then
#	if IsBound(tablespace[pp][generators[ih]]) and not tablespace[pp][generators[ih]]=sumlist[ih+1] then doweaddtable:=false; fi;
#	tablespace[pp][generators[ih]]:=sumlist[ih+1];
#else
#	if aa[ih]>1 or pointarray[ih]>0 then
#		if IsBound(tablespace[pp][generators[ih]]) and not tablespace[pp][generators[ih]]=aa[ih] then doweaddtable:=false; fi;
#		tablespace[pp][generators[ih]]:=aa[ih];
#	fi;
#	if aa[ih]=1 and pointarray[ih]=0 then
#		if IsBound(tablespace[pp][generators[ih]]) and not tablespace[pp][generators[ih]]=n+1 then doweaddtable:=false; fi;
#		tablespace[pp][generators[ih]]:=n+1;
#fi;
#fi;
#od;



#for is in Reversed([2..n]) do
#for ks in [1..gg] do
#if IsBound(tablespace[pp][tablespace[is][generators[ks]]]) and tablespace[pp][tablespace[is][generators[ks]]]=tablespace[tablespace[pp][is]][tablespace[pp][generators[ks]]] then doweaddtable:=false;
#fi;
#tablespace[pp][tablespace[is][generators[ks]]]:=tablespace[tablespace[pp][is]][tablespace[pp][generators[ks]]];
#od;
#od;

#for is in [n+1..pp] do
#tablespace[pp][is]:=tablespace[pp][tablespace[n+1][is]];
#od;

#if tablespace[pp][pp]=1 then continue; fi;

#for ks in [1..gg] do
#if tablespace[pp][generators[ks]]<=n and tablespace[tablespace[pp][generators[ks]]][tablespace[pp][generators[ks]]]>1 then doweaddtable:=false; fi;
#od;



#if doweaddtable 
#############################and fulldistributivitytest(tablespace) 
#then Add(mastertable[i],[tablespace,3]); fi;
#od;

#od;

#return List(generators,v->mastertable[v]);

#end;






#multirussianallextensions:=function(x)
#local generators,table,n,output,gg,ext,gentestkey,i,j,cart,tuple,tarm,ii,cardarray,tablearray,pointarray,mlonglist,mlist,sumlist,iz,ig,tablespace,newgenerators;

#generators:=x[1];
#table:=x[2];
#n:=Length(table);
#output:=[];
#gg:=Length(generators);

#ext:=multirussianextension(generators,table);

#gentestkey:=List([1..gg],v->[]);

#for i in [1..gg] do
#for j in [1..Length(ext[i])] do
#gentestkey[i][j]:=multirussiangentest(n,generators,ext[i][j][1]);
#od;
#od;

#cart:=Cartesian(List([1..gg],v->[1..Length(ext[v])]));

#for tuple in cart do

#tarm:=false;
#for ii in [1..gg] do
#if gentestkey[ii][tuple[ii]] then tarm:=true; break; fi;
#od;
#if not tarm then continue; fi;

##############3cardarray:=List([1..gg],v->mastertable[aa[v]][tuple[v]]);

#cardarray:=List([1..gg],v->ext[v][tuple[v]]);
#tablearray:=List(cardarray,v->v[1]);
#pointarray:=List(cardarray,v->v[2]);

#mlonglist:=List(tablearray,Length);
#mlist:=mlonglist-n;

#sumlist:=[n+1];

#for iz in [1..gg] do
#sumlist[iz+1]:=sumlist[iz]+mlist[iz]-1;
#od;


#tablespace:=multicombine(n,tablearray);

#newgenerators:=[];

#for ig in [1..gg] do
#if mlonglist[ig]>n+1 then 
#generators[ig]:=sumlist[ig+1];
#elif generators[ig]>1 then newgenerators[ig]:=generators[ig]; 
#elif generators[ig]=1 and pointarray[ig]=0 then newgenerators[ig]:=n+1;
#elif generators[ig]=1 and pointarray[ig]=1 then newgenerators[ig]:=1;
#fi;
#od;

#if Minimum(newgenerators)>n then
#Add(output,[newgenerators,tablespace]);
#fi;

#od;

#return output;
#end;
















