### This is the code for creating all multigenic Laver tables. We of course do not want to keep the entire table in memory, so we use a superreduced multigenic Laver table.
### In /multigeniccreate, we produce all tables generated by 2 elements, but here we produce all tables generated by an arbitrary collection of elements.
### The code is currently a work in progress.


makefunction:=function(compressedtable)
local n,tree;
n:=Length(compressedtable);
tree:=function(x,y)
if Length(compressedtable[x])=n then return compressedtable[x][y];
else
return compressedtable[x][compressedtable[Length(compressedtable[x])+1][y]];
fi;
end;
return tree;
end;

critfind:=function(table)
local critlist,i,n,tree;
n:=Length(table);
critlist:=[];
tree:=makefunction(table);
for i in [2..n] do
if tree(i,i)=1 then Add(critlist,i); fi;
od;
Add(critlist,1);
return critlist;
end;

#I am calling it wide generation, since we could have more than 2 generators.

multigeneration:=function(generators,table)
local n,mv,critlist,gg,superlist,im,j,superlength,supercrit,mastertable,ii,aa,cart,superfunction,sumlist,testlist,tablespace,imagespace,quart,js,mlist,testlistlength,
testlistcrit,tablearray,cardarray,imagearray,pointarray,ik,tuple,jj,testfunction,test,li,kk,iz,ham,qq,aar,kz,is;

n:=Length(table);
mv:=makefunction(table);
critlist:=critfind(table);
gg:=Length(generators);

superlist:=[];
for im in [1..n] do
for j in [1..Length(critlist)] do
if mv(im,critlist[j])=1 then superlist[im]:=j; break; fi;
od;
od;

superlength:=[];
supercrit:=[];

for im in [2..n] do
aa:=critlist[1+superlist[im]];
if aa>1 then superlength[im]:=aa-1; supercrit[im]:=aa;
else superlength[im]:=n; supercrit[im]:=n+1;
fi;
od;

# There is something wrong with superfunction.

superfunction:=function(x,y)
local ik,qq,ham;

if x=1000000000000 or y=1000000000000 then return 1000000000000; fi;
if x=1 then return y; fi;
#if y=1 then return 1; 
# I am not sure that this line of code is even necessary, so I am commenting it just in case.
#fi;

if y>n then
for ik in [1..gg] do
if y<=sumlist[ik+1] then return superfunction(x,imagearray[ik][y-sumlist[ik]+1]); fi;
od;
if y=sumlist[Length(sumlist)]+1 then return superfunction(x,ii); fi;
Print("EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE__off.by.one.error");
fi;

if x<=n then return mv(x,y); fi;
if x=n+1 then return y; fi;
for ik in [1..gg] do
if x<=sumlist[ik+1] then
qq:=Length(tablearray[ik][x-sumlist[ik]+1])+1;
# Around this line of code is problematic. I need to investigate.
ham:=tablearray[ik][x-sumlist[ik]+1][superfunction(qq,y)];
if ham<=n+1 then return ham; else
return ham+sumlist[ik]-n-1;
fi;
fi;

od;
if x=sumlist[Length(sumlist)]+1 then
if IsBound(testlist[superfunction(testlistcrit,y)]) then return testlist[superfunction(testlistcrit,y)];
else return 1000000000000; fi;
fi;
Print("WARNING:ERROR. PLEASE FIX CODE.");
end;

sanitycheck:=function()
local a,b,c,nnq;
nnq:=sumlist[Length(sumlist)];
for a in [1..nnq] do
for b in [1..nnq] do
for c in [1..nnq] do
if not superfunction(a,superfunction(b,c))=superfunction(superfunction(a,b),superfunction(a,c)) then
while true Display("Warning: self-distributive failure. Error in code."); od;
fi;
od;
od;
od;
end;

# In the testfunction, we need to verify that the square roots of the identity are in a one-to-one correspondence with the critical points.
testfunction:=function()
local aar,li,kk;

for li in [1..gg] do
if mlist[li]>1 then
if IsBound(testlist[superfunction(testlistcrit,generators[li])]) and not testlist[superfunction(testlistcrit,generators[li])]=sumlist[li+1] then 
Display("A");
return false; fi;
testlist[superfunction(testlistcrit,generators[li])]:=sumlist[li+1];

elif mlist[li]=1 then

# I do not think this is right either. What if the new algebra does not add anything at all?

if pointarray[li]=0 then
if IsBound(testlist[superfunction(testlistcrit,generators[li])]) and not testlist[superfunction(testlistcrit,generators[li])]=n+1 then Display("B"); return false; fi;
testlist[superfunction(testlistcrit,generators[li])]:=n+1;

elif pointarray[li]=1 then

if IsBound(testlist[superfunction(testlistcrit,generators[li])]) and not testlist[superfunction(testlistcrit,generators[li])]=1 then Display("C"); return false; fi;
testlist[superfunction(testlistcrit,generators[li])]:=1;

fi;
fi;

od;

for kk in Reversed([2..testlistlength]) do
for li in [1..gg] do

aar:=superfunction(superfunction(sumlist[Length(sumlist)]+1,kk),superfunction(sumlist[Length(sumlist)]+1,generators[li]));
if aar=false then Display("Q"); return false; fi;

# COMPUTATIONAL EVIDENCE SUGGESTS THAT THE FOLLOWING LINE OF CODE MAY NOT BE COMPLETELY CORRECT.

if IsBound(testlist[superfunction(kk,generators[li])]) and not testlist[superfunction(kk,generators[li])]=aar then Display("D"); return false; fi;
testlist[superfunction(kk,generators[li])]:=aar;
od;
od;

if not testlist[1]=1 then Display("E"); return false; fi;

#if doublesuperfunction(n+mzero+mone,ii)=1 then return false; fi;
if superfunction(sumlist[Length(sumlist)]+1,ii)=1 then Display("F"); return false; fi;

return true;
end;


mastertable:=[];

mastertable[1]:=[];
mastertable[1][1]:=[];
mastertable[1][1][1]:=[1];
mastertable[1][1][2]:=[[1..n]];
mastertable[1][1][3]:=0;
mastertable[1][2]:=[];
mastertable[1][2][1]:=[1];
mastertable[1][2][2]:=[[1..n]];
mastertable[1][2][3]:=1;




for ii in [2..n] do

mastertable[ii]:=[];
mastertable[ii][1]:=[[1],[1..n],1];

aa:=[];
for jj in [1..gg] do
aa[jj]:=mv(ii,generators[jj]);
od;

#Um. What if everything is above?



cart:=Cartesian(List(aa,v->[1..Length(mastertable[v])]));

Display(Length(cart));

for tuple in cart do

# I NEED TO DOUBLE CHECK CARDARRAY.

cardarray:=List([1..gg],v->mastertable[aa[v]][tuple[v]]);
imagearray:=List(cardarray,v->v[1]);
tablearray:=List(cardarray,v->v[2]);
pointarray:=List(cardarray,v->v[3]);

mlist:=List([1..gg],v->Length(imagearray[v]));

sumlist:=[n+1];

for iz in [1..gg] do
sumlist[iz+1]:=sumlist[iz]+mlist[iz]-1;
od;

testlist:=[];
testlistlength:=superlength[ii];
testlistcrit:=supercrit[ii];

sanitycheck();
test:=testfunction();

if test then

#I am confused as to why we have a shallow copy and not a structural copy.
imagespace:=ShallowCopy(imagearray[1]);
for kz in [2..gg] do
for is in [2..Length(imagearray[kz])] do
Add(imagespace,imagearray[kz][is]);
od;
od;


tablespace:=ShallowCopy(tablearray[1]);

for kz in [2..gg] do
for is in [2..Length(tablearray[kz])] do
quart:=ShallowCopy(tablearray[kz][is]);
# YEAH. THE OD'S ARE IN THE WRONG SPOT!!!
for js in [1..Length(quart)] do
if quart[js]>n+1 then
quart[js]:=quart[js]+sumlist[kz]-n-1;
fi;
od;
Add(tablespace,quart);

od;
od;


if superfunction(sumlist[Length(sumlist)]+1,critlist[superlist[ii]])=1 then
while Length(testlist)>=critlist[superlist[ii]] do Remove(testlist); od;
fi;

Add(imagespace,ii);
Add(tablespace,testlist);
Add(mastertable[ii],[imagespace,tablespace,0]);

fi;

od;
od;

# By returning this, we are also returning tables that add nothing interesting.
#return List(generators,v->mastertable[v]); 
car=car;
end;


############END NEW##############################################
#################################################################
#################################################################


totalgeneration:=function(limit,zero,one,table)
local im,n,mv,critlist,superlist,i,j,superlength,supercrit,aa,ii,superfunction,doublesuperfunction,imagezero,imageone,testlistcrit,testlistlength,mzero,mone,tablezero,tableone,
mastertable,bb,qq,imagespace,card,cardzero,cardone,mm,tablespace,qqq,rrr,jj,kk,testfunction,test,aar,bbr,newtablespace,newimagespace,testlist,ttt,doubletestfunction,quart,is,js,ri,rj,ham,
parkzero,parkone,aaa,b;

n:=Length(table);

mv:=makefunction(table);
critlist:=critfind(table);

superlist:=[];
for im in [1..n] do
for j in [1..Length(critlist)] do
if mv(im,critlist[j])=1 then superlist[im]:=j; break; fi;
od;
od;

superlength:=[];
supercrit:=[];

for im in [2..n] do
aa:=critlist[1+superlist[im]];
if aa>1 then superlength[im]:=aa-1; supercrit[im]:=aa;
else superlength[im]:=n; supercrit[im]:=n+1;
fi;
od;

mastertable:=[];

mastertable[1]:=[];
mastertable[1][1]:=[];
mastertable[1][1][1]:=[1];
mastertable[1][1][2]:=[[1..n]];


superfunction:=function(x,y)
if x=1000000000000 or y=1000000000000 then return 1000000000000; fi;
if x=1 then return y; fi;
if y>n then return superfunction(x,imagespace[y-n]); fi;
if x<=n then return mv(x,y); fi;
if x=n+1 then return y; fi;
if x<=n+mm then
qq:=Length(tablespace[x-n])+1;
return tablespace[x-n][superfunction(qq,y)];
fi;
if x=n+mm+1 then 
if IsBound(testlist[superfunction(testlistcrit,y)]) then return testlist[superfunction(testlistcrit,y)];
else return 1000000000000; fi;
fi;
Print("WARNING:OFF.BY.ONE.ERROR");
end;


doublesuperfunction:=function(x,y)
if x=1000000000000 or y=1000000000000 then return 1000000000000; fi;
if x=1 then return y; fi;
if y>n then
if y<=n+mzero then return doublesuperfunction(x,imagezero[y-n]);
elif y<=n+mzero+mone-1 then return doublesuperfunction(x,imageone[y-n-mzero+1]); 
elif y=n+mzero+mone then return doublesuperfunction(x,ii);
else Print("EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE__off.by.one.error");
fi;
fi;

if x<=n then return mv(x,y); fi;
if x=n+1 then return y; fi;
if x<=n+mzero then
qq:=Length(tablezero[x-n])+1;
return tablezero[x-n][doublesuperfunction(qq,y)];
fi;
if x<=n+mzero+mone-1 then
qq:=Length(tableone[x-n-mzero+1])+1;
ham:=tableone[x-n-mzero+1][doublesuperfunction(qq,y)];
if ham<=n+1 then return ham;
else return ham+mzero-1;
fi;

fi;
if x=n+mzero+mone then
if IsBound(testlist[doublesuperfunction(testlistcrit,y)]) then return testlist[doublesuperfunction(testlistcrit,y)]; else
return 1000000000000; fi;
fi;
end;

doubletestfunction:=function()

if IsBound(testlist[doublesuperfunction(testlistcrit,zero)]) then if not testlist[doublesuperfunction(testlistcrit,zero)]=n+mzero then return false; fi; fi;
testlist[doublesuperfunction(testlistcrit,zero)]:=n+mzero;

if mone>1 then

if IsBound(testlist[doublesuperfunction(testlistcrit,one)]) then if not testlist[doublesuperfunction(testlistcrit,one)]=n+mzero+mone-1 then return false; fi; fi;
testlist[doublesuperfunction(testlistcrit,one)]:=n+mzero+mone-1;

elif mone=1 then

if IsBound(testlist[doublesuperfunction(testlistcrit,one)]) then if not testlist[doublesuperfunction(testlistcrit,one)]=n+1 then return false; fi; fi;
testlist[doublesuperfunction(testlistcrit,one)]:=n+1;

else Print("EEEEEEEEEEEE"); fi;

for kk in Reversed([2..testlistlength]) do
aar:=doublesuperfunction(doublesuperfunction(n+mzero+mone,kk),doublesuperfunction(n+mzero+mone,zero));
if aar=false then return false; fi;
if IsBound(testlist[doublesuperfunction(kk,zero)]) and not testlist[doublesuperfunction(kk,zero)]=aar then return false; fi;
testlist[doublesuperfunction(kk,zero)]:=aar;

bbr:=doublesuperfunction(doublesuperfunction(n+mzero+mone,kk),doublesuperfunction(n+mzero+mone,one));
if bbr=false then return false; fi;
if IsBound(testlist[doublesuperfunction(kk,one)]) and not testlist[doublesuperfunction(kk,one)]=bbr then return false; fi;
testlist[doublesuperfunction(kk,one)]:=bbr;

od;

if not testlist[1]=1 then return false; fi;

if doublesuperfunction(n+mzero+mone,ii)=1 then return false; fi;

return true;
end;


testfunction:=function()

if ttt=0 then card:=mastertable[aa][jj]; else card:=mastertable[bb][jj-qqq]; fi;


if ttt=0 then
if IsBound(testlist[superfunction(testlistcrit,zero)]) then if not testlist[superfunction(testlistcrit,zero)]=n+mm then 
return false; fi; fi;
testlist[superfunction(testlistcrit,zero)]:=n+mm;

if IsBound(testlist[superfunction(testlistcrit,one)]) then if not testlist[superfunction(testlistcrit,one)]=mv(ii,one) then 
return false; fi; fi;
testlist[superfunction(testlistcrit,one)]:=mv(ii,one);
else

if IsBound(testlist[superfunction(testlistcrit,zero)]) then if not testlist[superfunction(testlistcrit,zero)]=mv(ii,zero) then 
return false; fi; fi;
testlist[superfunction(testlistcrit,zero)]:=mv(ii,zero);

if IsBound(testlist[superfunction(testlistcrit,one)]) then if not testlist[superfunction(testlistcrit,one)]=n+mm then 
return false; fi; fi;
testlist[superfunction(testlistcrit,one)]:=n+mm;
fi;

for kk in Reversed([2..testlistlength]) do
aar:=superfunction(superfunction(n+mm+1,kk),superfunction(n+mm+1,zero));
if aar=false then return false; fi;
if IsBound(testlist[superfunction(kk,zero)]) and not testlist[superfunction(kk,zero)]=aar then 
 return false; fi;
testlist[superfunction(kk,zero)]:=aar;

bbr:=superfunction(superfunction(n+mm+1,kk),superfunction(n+mm+1,one));
if bbr=false then return false; fi;
if IsBound(testlist[superfunction(kk,one)]) and not testlist[superfunction(kk,one)]=bbr then 
return false; fi;
testlist[superfunction(kk,one)]:=bbr;

od;

if not testlist[1]=1 then 
return false; fi;

if superfunction(n+mm+1,ii)=1 then return false; fi;

return true;
end;


for ii in [2..n] do

aa:=mv(ii,zero);
bb:=mv(ii,one);
mastertable[ii]:=[];

if mv(ii,ii)>1 and mv(aa,aa)=1 and mv(bb,bb)=1 then
imagespace:=[1,ii];
tablespace:=[[1..n],StructuralCopy(table[ii])];

Add(mastertable[ii],[imagespace,tablespace]);
fi;


qqq:=Length(mastertable[aa]);
rrr:=Length(mastertable[bb]);

for jj in [1..qqq+rrr] do
if jj<=qqq then ttt:=0; else ttt:=1; fi;

if ttt=0 and mv(bb,bb)>1 then continue; fi;
if ttt=1 and mv(aa,aa)>1 then continue; fi;

if ttt=0 then card:=mastertable[aa][jj]; else card:=mastertable[bb][jj-qqq]; fi;
imagespace:=card[1];
tablespace:=card[2];
mm:=Length(imagespace);

if mm+1>limit then continue; fi;

testlist:=[];
testlistlength:=superlength[ii];
testlistcrit:=supercrit[ii];

test:=testfunction();

if test then
newimagespace:=ShallowCopy(imagespace);
newtablespace:=ShallowCopy(tablespace);


if superfunction(n+mm+1,critlist[superlist[ii]])=1 then
while Length(testlist)>=critlist[superlist[ii]] do Remove(testlist); od;
fi;

Add(newimagespace,ii);
Add(newtablespace,testlist);

Add(mastertable[ii],[newimagespace,newtablespace]);

fi;

od;

for ri in [1..Length(mastertable[aa])] do
for rj in [1..Length(mastertable[bb])] do

cardzero:=mastertable[aa][ri];
cardone:=mastertable[bb][rj];

imagezero:=cardzero[1];
imageone:=cardone[1];

tablezero:=cardzero[2];
tableone:=cardone[2];

mzero:=Length(imagezero);
mone:=Length(imageone);

if mzero+mone>limit then continue; fi;

testlist:=[];
testlistlength:=superlength[ii];
testlistcrit:=supercrit[ii];

test:=doubletestfunction();
if test then
imagespace:=ShallowCopy(imagezero);
tablespace:=ShallowCopy(tablezero);
for is in [2..Length(imageone)] do
Add(imagespace,imageone[is]);
od;
for is in [2..Length(tableone)] do
quart:=ShallowCopy(tableone[is]);
for js in [1..Length(quart)] do
if quart[js]>n+1 then
quart[js]:=quart[js]+mzero-1;
fi;
od;

Add(tablespace,quart);
od;

if doublesuperfunction(n+mzero+mone,critlist[superlist[ii]])=1 then
while Length(testlist)>=critlist[superlist[ii]] do Remove(testlist); od;
fi;

Add(imagespace,ii);
Add(tablespace,testlist);

Add(mastertable[ii],[imagespace,tablespace]);
fi;

od;
od;


od;

parkzero:=[];
parkone:=[];

#Here we have an issue of the table not accepting generators. Sad.

#for card in mastertable[zero] do
#test:=false;
#tablespace:=card[2];
#for aaa in tablespace do
#if test then break; fi;
#for b in aaa do
#if b=n+1 then test:=true; break; fi;
#od;
#od;
#if test or Length(tablespace)=1 then Add(parkzero,card); fi;
#od;
#for card in mastertable[one] do
#test:=false;
#tablespace:=card[2];
#for aaa in tablespace do
#if test then break; fi;
#for b in aaa do
#if b=n+1 then test:=true; break; fi;
#od;
#od;
#if test or Length(tablespace)=1 then Add(parkone,card); fi;
#od;

cow:=cow;

return [mastertable[zero],mastertable[one]];

#return [parkzero,parkone];
end;


extendtable:=function(type,number,xx,extension)
local har,n,quack,i,j,mzero,hack,rack,zeroext,oneext;

n:=Length(xx[3]);

if type<2 then
if type=0 then
Append(xx[3],StructuralCopy(extension[1][number][2]));
xx[1]:=Length(xx[3]);
Append(xx[3][n+1],StructuralCopy(extension[1][number][1]));
for i in [1..n] do
if Length(xx[3][i])=n then Append(xx[3][i],StructuralCopy(List(extension[1][number][1],v->xx[3][i][v]))); fi;
od;
xx[3][1]:=[1..Length(xx[3][1])];
else
Append(xx[3],StructuralCopy(extension[2][number][2]));
xx[2]:=Length(xx[3]);
Append(xx[3][n+1],StructuralCopy(extension[2][number][1]));
fi;
for i in [1..n] do
if Length(xx[3][i])=n then Append(xx[3][i],StructuralCopy(List(extension[2][number][1],v->xx[3][i][v]))); fi;
od;
xx[3][1]:=[1..Length(xx[3][1])];
else

zeroext:=StructuralCopy(extension[1][number[1]]);
oneext:=StructuralCopy(extension[2][number[2]]);

Append(xx[3],zeroext[2]);
xx[1]:=Length(xx[3]);

Append(xx[3][n+1],zeroext[1]);

mzero:=Length(zeroext[2]);

har:=StructuralCopy(oneext[2]);

for i in [2..Length(har)] do
quack:=har[i];
for j in [1..Length(quack)] do
if quack[j]>n+1 then 
quack[j]:=quack[j]+mzero-1;
fi;
od;
Add(xx[3],quack);
od;


xx[2]:=Length(xx[3]);

if Length(oneext[2])=1 then
xx[2]:=n+1;
fi;


hack:=StructuralCopy(zeroext[1]);

rack:=StructuralCopy(oneext[1]);


for i in [2..Length(rack)] do
if rack[i]<=n+1 then Add(hack,rack[i]);
else
Add(hack,rack[i]+mzero-1);
fi;
od;

for i in [1..n] do
if Length(xx[3][i])=n then Append(xx[3][i],List(hack,v->xx[3][i][v])); fi;
od;
xx[3][1]:=[1..Length(xx[3][1])];
xx[3][n+1]:=Concatenation([1..n],hack);

fi;

end;



allextensions:=function(tar,x)
local ext,list,i,xx,newext,j,full,limit,n,marchlist,card,test,aaa,b,tablespace;

mv:=makefunction(x[3]);

n:=Length(x[3]);

if not IsInt(tar) then limit:=infinity; else limit:=tar; fi;
full:=not (tar=false);

ext:=totalgeneration(limit,x[1],x[2],x[3]);
list:=[];

marchlist:=[[],[]];

for card in ext[1] do
test:=false;
tablespace:=card[2];
for aaa in tablespace do
if test then break; fi;
for b in aaa do
if b=n+1 then test:=true; break; fi;
od;
od;
if test or Length(tablespace)=1 then Add(marchlist[1],1); 
else Add(marchlist[1],0); fi;
od;

for card in ext[2] do
test:=false;
tablespace:=card[2];
for aaa in tablespace do
if test then break; fi;
for b in aaa do
if b=n+1 then test:=true; break; fi;
od;
od;
if test or Length(tablespace)=1 then Add(marchlist[2],1); 
else Add(marchlist[2],0); fi;
od;



for i in [1..Length(ext[1])] do
if mv(x[2],x[2])>1 then break; fi;

if Length(ext[1][i][2])>limit then continue; fi;

if marchlist[1][i]=0 then continue; fi;

xx:=StructuralCopy(x);
extendtable(0,i,xx,ext);



Add(list,xx);
od;
for j in [1..Length(ext[2])] do
if mv(x[1],x[1])>1 then break; fi;

if Length(ext[2][j][2])>limit then continue; fi;

if marchlist[2][j]=0 then continue; fi;

xx:=StructuralCopy(x);
extendtable(1,j,xx,ext);
Add(list,xx);
od;

if full then
for i in [1..Length(ext[1])] do
for j in [1..Length(ext[2])] do
if Length(ext[1][i][2])+Length(ext[2][j][2])-1>limit then continue; fi;

if marchlist[1][i]=0 and marchlist[2][j]=0 then continue; fi;

xx:=StructuralCopy(x);
extendtable(2,[i,j],xx,ext);
Add(list,xx);
od;
od;
fi;
return list;
end;

expandtable:=function(table)
local n,mv,ttt;
n:=Length(table);
mv:=makefunction(table);
ttt:=List([1..n],u->List([1..n],v->mv(u,v)));
return ttt;
end;

russiancombinetable:=function(n,tablezero,tableone)
local mzero,mone,tablespace,adjrow,is,js,i,j;

mzero:=Length(tablezero);
mone:=Length(tableone);
tablespace:=StructuralCopy(tablezero);

for is in [n+2..mone] do
Add(tablespace[n+1],tableone[n+1][is]);
adjrow:=[];
for js in [1..n] do
if tableone[is][js]<=n+1 then adjrow[js]:=tableone[is][js];
else
adjrow[js]:=tableone[is][js]+mzero-(n+1);
fi;
od;

Add(tablespace,adjrow);
od;

for j in [1..Length(tablespace)] do
tablespace[1][j]:=j;
for i in [2..Length(tablespace)] do
tablespace[i][j]:=tablespace[i][tablespace[n+1][j]];
od;
od;

return tablespace;
end;

generationtest:=function(x)
local zero,one,table,n,axe,m,i,j;
zero:=x[1];
one:=x[2];
table:=x[3];
n:=Length(table);

axe:=[zero,one];

m:=Length(axe);
while true do
for i in [1..m] do
for j in [1..m] do
Add(axe,table[axe[i]][axe[j]]);
od;
od;
axe:=Unique(axe);
if Length(axe)=m then break; fi;
m:=Length(axe);
od;
return n=m;
end;


# I need to modify the russianextension function some more.
# We can only go from below to above if we hit a critical point. i.e. We can only go from below to above once we hit a square root of 1.

# aa=exttable[i][zero];
# bb=exttable[i][one];
# If the new element is less than 1
#

russianextension:=function(zero,one,table)
local n,exttable,mastertable,aa,bb,qqq,rrr,rj,rk,cardzero,cardone,tablezero,tableone,pointzero,pointone,mzero,mone,tablespace,doweaddtable,is,pp,js,i;

n:=Length(table);
exttable:=StructuralCopy(table);
exttable[n+1]:=[1..n];
exttable[1][n+1]:=n+1;
for i in [2..n+1] do
exttable[i][n+1]:=1;
od;

mastertable:=[];
mastertable[1]:=[[StructuralCopy(exttable),0],[StructuralCopy(exttable),1]];

for i in [2..n] do
mastertable[i]:=[];

Add(mastertable[i],[StructuralCopy(exttable),2]);

aa:=exttable[i][zero];
bb:=exttable[i][one];

for cardzero in mastertable[aa] do
for cardone in mastertable[bb] do

doweaddtable:=true;

tablezero:=cardzero[1];
tableone:=cardone[1];
pointzero:=cardzero[2];
pointone:=cardone[2];
mzero:=Length(tablezero);
mone:=Length(tableone);

tablespace:=russiancombinetable(n,tablezero,tableone);

Add(tablespace,[]);

pp:=Length(tablespace);

tablespace[1][pp]:=pp;
for is in [2..pp-1] do tablespace[is][pp]:=tablespace[is][i]; od;

if mzero>n+1 then 
if IsBound(tablespace[pp][zero]) and not tablespace[pp][zero]=mzero then doweaddtable:=false; fi;
tablespace[pp][zero]:=mzero;
else
if aa>1 or pointzero>0 then 
if IsBound(tablespace[pp][zero]) and not tablespace[pp][zero]=aa then doweaddtable:=false; fi;
tablespace[pp][zero]:=aa; 
fi;
if aa=1 and pointzero=0 then 
if IsBound(tablespace[pp][zero]) and not tablespace[pp][zero]=n+1 then doweaddtable:=false; fi;
tablespace[pp][zero]:=n+1; 
fi;
fi;
#if IsBound( ) and not  then doweaddtable:=false; fi;

if mone>n+1 then 
if IsBound(tablespace[pp][one]) and not tablespace[pp][one]=pp-1 then doweaddtable:=false; fi;
tablespace[pp][one]:=pp-1;
else
if bb>1 or pointone>0 then 
if IsBound(tablespace[pp][one]) and not tablespace[pp][one]=bb then doweaddtable:=false; fi;
tablespace[pp][one]:=bb; 
fi;
if bb=1 and pointone=0 then 
if IsBound(tablespace[pp][one]) and not tablespace[pp][one]=n+1 then doweaddtable:=false; fi;
tablespace[pp][one]:=n+1; 
fi;
fi;

for is in Reversed([2..n]) do
if IsBound(tablespace[pp][tablespace[is][zero]]) and not tablespace[pp][tablespace[is][zero]]=tablespace[tablespace[pp][is]][tablespace[pp][zero]] then doweaddtable:=false; fi;
tablespace[pp][tablespace[is][zero]]:=tablespace[tablespace[pp][is]][tablespace[pp][zero]];

if IsBound(tablespace[pp][tablespace[is][one]]) and not tablespace[pp][tablespace[is][one]]=tablespace[tablespace[pp][is]][tablespace[pp][one]] then doweaddtable:=false; fi;
tablespace[pp][tablespace[is][one]]:=tablespace[tablespace[pp][is]][tablespace[pp][one]];
od;

for is in [n+1..pp] do
tablespace[pp][is]:=tablespace[pp][tablespace[n+1][is]];
od;

if tablespace[pp][pp]=1 then continue; fi;



if tablespace[pp][zero]<=n and tablespace[tablespace[pp][zero]][tablespace[pp][zero]]>1 then doweaddtable:=false; fi;
if tablespace[pp][one]<=n and tablespace[tablespace[pp][one]][tablespace[pp][one]]>1 then doweaddtable:=false; fi;

if doweaddtable 
#and fulldistributivitytest(tablespace) 
then Add(mastertable[i],[tablespace,3]); fi;
od;
od;

od;

parkzero:=[];
parkone:=[];

#for aa in parkzero do
#if midtabletest(0,newzero,newone,newtable) then Add(parkzero,aa); fi;
#od;
#for bb in parkone do
#if midtabletest(0,newzero,newone,newtable) then Add(parkone,bb); fi;
#od;

#return [parkzero,parkone];

return [mastertable[zero],mastertable[one]];
end;





midtabletest:=function(bit,zero,one,table)
local critlist,a,b,i,j,maxcrit;

if not fullgenerationtest([zero,one],table) then return false; fi;

critlist:=critfind(table);
maxcrit:=Maximum(critlist);
Remove(critlist);
Add(critlist,Length(table)+1);
for i in [2..Length(critlist)] do
a:=critlist[i-1];
b:=critlist[i];
for j in [a+1..b-1] do
if table[j][zero]<a and table[table[j][zero]][table[j][zero]]>1 then return false; fi;
if table[j][one]<a and table[table[j][one]][table[j][one]]>1 then return false; fi;
od;
od;

if not bit=1 then if table[zero][zero]>1 and zero<maxcrit then return false; fi; fi;
if not bit=0 then if table[one][one]>1 and one<maxcrit then return false; fi; fi;

return true;
end;




# I can probably extend the midtabletest to a left midtable test and a right midtable test.

fastmidtabletest:=function(zero,one,table)
local critlist,a,b,i,j,maxcrit;
critlist:=critfind(table);
maxcrit:=Maximum(critlist);
n:=Length(table);

return true;
end;


#For russianallextensions or the above function, we need to be able to eliminate the cases where we do not generate the new critical point with the same two elements.
#However, we only need to be able to generate the new critical point in one way.

russiangentest:=function(n,zero,one,table)
local a,b,c,list;
if Length(table)<=n+1 then return true; fi;
list:=[Length(table)];
while Length(list)>0 do
a:=Remove(list);
if a=n+1 then return true; fi;
b:=table[a][zero];
c:=table[a][one];
if b>n then Add(list,b); fi;
if c>n then Add(list,c); fi;
od;
return false;
end;

multirussiangentest:=function(n,generators,table)
local a,b,c,list;

if Length(table)<=n+1 then return true; fi;
list:=[Length(table)];
while Length(list)>0 do
a:=Remove(list);
if a=n+1 then return true; fi;
for b in generators do
c:=table[a][b];
if c>n then Add(list,c); fi;
od;
od;
return false;
end;


russianallextensions:=function(x)
local gentestkey,zero,one,table,n,cardzero,cardone,tablezero,tableone,pointzero,pointone,output,ext,mzero,mone,tablespace,newzero,newone,amm,preext,i;

zero:=x[1];
one:=x[2];
table:=x[3];
n:=Length(table);
output:=[];

ext:=russianextension(zero,one,table);

gentestkey:=[[],[]];

for i in [1,2] do
for j in [1..Length(ext[i])] do
gentestkey[i][j]:=russiangentest(n,zero,one,ext[i][j][1]);
od;
od;

for i in [1..Length(ext[1])] do
for j in [1..Length(ext[2])] do
if not gentestkey[1][i] and not gentestkey[2][j] then continue; fi;

cardzero:=ext[1][i];
cardone:=ext[2][j];
tablezero:=cardzero[1];
tableone:=cardone[1];
pointzero:=cardzero[2];
pointone:=cardone[2];
mzero:=Length(tablezero);
mone:=Length(tableone);
tablespace:=russiancombinetable(n,tablezero,tableone);

# I NEED TO MODIFY THE FOLLOWING STATEMENTS!

if mzero>n+1 then newzero:=mzero;
elif zero>1 then newzero:=zero;
elif zero=1 and pointzero=0 then newzero:=n+1;
elif zero=1 and pointzero=1 then newzero:=1;
fi;

if mone>n+1 then newone:=Length(tablespace);
elif one>1 then newone:=one;
elif one=1 and pointone=0 then newone:=n+1;
elif one=1 and pointone=1 then newone:=1;
fi;

if newone>n or newzero>n then
Add(output,[newzero,newone,tablespace]);
fi;
od;
od;

return output;
end;


# I need to write the code for determining whether 


strongrussianallextensions:=function(xx) local pan,y,can; can:=russianallextensions(xx); pan:=[]; for y in can do if midtabletest(true,y[1],y[2],y[3]) then Add(pan,y); fi; od; return pan; end;

multicombine:=function(n,tablelist)
local i,tablespace,gg;

gg:=Length(tablelist);
tablespace:=StructuralCopy(tablelist[1]);
for i in [2..gg] do
tablespace:=russiancombinetable(n,tablespace,tablelist[i]);
od;
return tablespace;
end;

multirussianextension:=function(generators,table)
local n,exttable,i,mastertable,aa,cart,tuple,cardarray,tablearray,pointarray,tablespace,doweaddtable,pp,ks,gg,is,sumlist,iz,mlonglist,mlist,j,jj,ih;

n:=Length(table);
exttable:=StructuralCopy(table);
exttable[n+1]:=[1..n];
exttable[1][n+1]:=n+1;
for i in [2..n+1] do
exttable[i][n+1]:=1;
od;
gg:=Length(generators);

mastertable:=[];
mastertable[1]:=[[StructuralCopy(exttable),0],[StructuralCopy(exttable),1]];

for i in [2..n] do
mastertable[i]:=[];

Add(mastertable[i],[StructuralCopy(exttable),2]);
aa:=[];
for jj in [1..gg] do
aa[jj]:=exttable[i][generators[jj]];
od;

cart:=Cartesian(List(aa,v->[1..Length(mastertable[v])]));

for tuple in cart do

cardarray:=List([1..gg],v->mastertable[aa[v]][tuple[v]]);

tablearray:=List(cardarray,v->v[1]);
pointarray:=List(cardarray,v->v[2]);

tablespace:=multicombine(n,tablearray);

doweaddtable:=true;

mlonglist:=List(tablearray,Length);

mlist:=mlonglist-n;

sumlist:=[n+1];

for iz in [1..gg] do
sumlist[iz+1]:=sumlist[iz]+mlist[iz]-1;
od;

Add(tablespace,[]);

pp:=Length(tablespace);

tablespace[1][pp]:=pp;
for is in [2..pp-1] do tablespace[is][pp]:=tablespace[is][i]; od;

for ih in [1..gg] do
if mlonglist[ih]>n+1 then
	if IsBound(tablespace[pp][generators[ih]]) and not tablespace[pp][generators[ih]]=sumlist[ih+1] then doweaddtable:=false; fi;
	tablespace[pp][generators[ih]]:=sumlist[ih+1];
else
	if aa[ih]>1 or pointarray[ih]>0 then
		if IsBound(tablespace[pp][generators[ih]]) and not tablespace[pp][generators[ih]]=aa[ih] then doweaddtable:=false; fi;
		tablespace[pp][generators[ih]]:=aa[ih];
	fi;
	if aa[ih]=1 and pointarray[ih]=0 then
		if IsBound(tablespace[pp][generators[ih]]) and not tablespace[pp][generators[ih]]=n+1 then doweaddtable:=false; fi;
		tablespace[pp][generators[ih]]:=n+1;
	fi;
fi;
od;



for is in Reversed([2..n]) do
for ks in [1..gg] do
if IsBound(tablespace[pp][tablespace[is][generators[ks]]]) and tablespace[pp][tablespace[is][generators[ks]]]=tablespace[tablespace[pp][is]][tablespace[pp][generators[ks]]] then doweaddtable:=false;
fi;
tablespace[pp][tablespace[is][generators[ks]]]:=tablespace[tablespace[pp][is]][tablespace[pp][generators[ks]]];
od;
od;

for is in [n+1..pp] do
tablespace[pp][is]:=tablespace[pp][tablespace[n+1][is]];
od;

if tablespace[pp][pp]=1 then continue; fi;

for ks in [1..gg] do
if tablespace[pp][generators[ks]]<=n and tablespace[tablespace[pp][generators[ks]]][tablespace[pp][generators[ks]]]>1 then doweaddtable:=false; fi;
od;



if doweaddtable 
#############################and fulldistributivitytest(tablespace) 
then Add(mastertable[i],[tablespace,3]); fi;
od;

od;

return List(generators,v->mastertable[v]);

end;






multirussianallextensions:=function(x)
local generators,table,n,output,gg,ext,gentestkey,i,j,cart,tuple,tarm,ii,cardarray,tablearray,pointarray,mlonglist,mlist,sumlist,iz,ig,tablespace,newgenerators;

generators:=x[1];
table:=x[2];
n:=Length(table);
output:=[];
gg:=Length(generators);

ext:=multirussianextension(generators,table);

gentestkey:=List([1..gg],v->[]);

for i in [1..gg] do
for j in [1..Length(ext[i])] do
gentestkey[i][j]:=multirussiangentest(n,generators,ext[i][j][1]);
od;
od;

cart:=Cartesian(List([1..gg],v->[1..Length(ext[v])]));

for tuple in cart do

tarm:=false;
for ii in [1..gg] do
if gentestkey[ii][tuple[ii]] then tarm:=true; break; fi;
od;
if not tarm then continue; fi;

#cardarray:=List([1..gg],v->mastertable[aa[v]][tuple[v]]);

cardarray:=List([1..gg],v->ext[v][tuple[v]]);
tablearray:=List(cardarray,v->v[1]);
pointarray:=List(cardarray,v->v[2]);

mlonglist:=List(tablearray,Length);
mlist:=mlonglist-n;

sumlist:=[n+1];

for iz in [1..gg] do
sumlist[iz+1]:=sumlist[iz]+mlist[iz]-1;
od;


tablespace:=multicombine(n,tablearray);

newgenerators:=[];

for ig in [1..gg] do
if mlonglist[ig]>n+1 then 
generators[ig]:=sumlist[ig+1];
elif generators[ig]>1 then newgenerators[ig]:=generators[ig]; 
elif generators[ig]=1 and pointarray[ig]=0 then newgenerators[ig]:=n+1;
elif generators[ig]=1 and pointarray[ig]=1 then newgenerators[ig]:=1;
fi;
od;

if Minimum(newgenerators)>n then
Add(output,[newgenerators,tablespace]);
fi;

od;

return output;
end;
















